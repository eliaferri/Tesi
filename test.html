<!--
    subject_areas_categories = {
        '1702': 'Artificial Intelligence',
        '1800': 'General Decision Science',
        '1801': 'Decision Sciences',
        '1802': 'Information Systems and Management',
        '1803': 'Management Science and Operations Research',
        '1804': 'Statistics, Probability and Uncertainty',
        '2613': 'Statistics and Probability',

        '1702': 'limegreen',
        '1800': 'darkturquoise',
        '1801': 'royalblue',
        '1802': 'magenta',
        '1803': 'gold',
        '1804': 'red',
        '2613': 'orangered',

        range: [
            'limegreen',
            'darkturquoise',
            'royalblue',
            'magenta',
            'gold',
            'red',
            'orangered'
          ],

        patello chiaro (troppo chiaro)
        range: [
            '#D5EDB9', //verde chiaro
            '#A4E1E9', //azzurro chiaro
            '#789CCE', //blu
            '#C4BDF3', //viola
            '#FBE8A4', //giallo
            '#FAC9DC', //rosso
            '#FFC198', //arancione
          ],

        palette chiara (rosso/arancio sovrapposti)
        range: [
            '#2ecc71', //verde chiaro
            '#fac9dc', //rosa
            '#3498db', //blu
            '#9b59b6', //viola
            '#f39c12', //giallo
            '#d9534f', //rosso
            '#FF5733', //arancione
          ],
    }
-->

  <body>
      <div id="deepscatter">
        <div class="overlay">
          <div id="color-legend"></div>
        </div>
      </div>

      <div class="searchbar">
        <h3 class="search-title"> The Landscape of Data Science Research </h3>
        
        <input id="query-value" name="query-value" type="text" class="query-input">

        <select id="query-field" class="query-input" name="query-field">
          <option value="title">Title</option>
          <option value="author">Author</option>
          <option value="pubdate">Publication Year</option>        
        </select>

        <button id="search-btn" class="query-input search-btn"> Search </button>
        <button id="search-reset-btn"  class="query-input search-btn"> Reset </button>
      </div>

      <div class="rect-search">
        <h3 class="search-title"> Rect-search </h3>
        
        <label for="xmin-value"> Point A: <label>
        <input id="xmin-value" class="query-input rect-search-input" name="xmin-value" type="number" value="-10">
        <input id="ymin-value" class="query-input rect-search-input" name="ymin-value" type="number" value="-10"><br>
        <label for="xmin-value"> Point B:</label>
        <input id="xmax-value" class="query-input rect-search-input" name="xmax-value" type="number" value="10">
        <input id="ymax-value" class="query-input rect-search-input" name="ymax-value" type="number" value="10"><br>
        <button id="rect-search-btn" class="query-input search-btn"> Search </button>
        <button id="rect-reset-btn"  class="query-input search-btn"> Reset </button>

        <div id="selected-rect-legend"> </div>

      </div>

      <div class="extra-options">
        <div id="light-dark-mode">
          <button id="swap-palette-btn" class="extra-btn"> Change Palette </button>
          <button id="hide-labels-btn" class="extra-btn"> Hide Keywords </button>
          <button id="info-btn" class="extra-btn popup"> More Info </button>

          <div id="info-modal" class="modal">

            <div class="modal-content">
              <div class="modal-header">
                <span class="close-modal">&times;</span>
              </div>
              <div class="modal-body">
                <h2>The Landscape of Data Science Research</h2>
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
                <br>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
                <p>Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p>
              </div>
              <div class="modal-footer">
                <h4>&copy; 2024 - Universita' degli Studi di Milano</h4>
              </div>
            </div>
          
          </div>

        </div>
      </div>
  </body>
  
  <script type="module">
    import Scatterplot from './src/deepscatter';
    import { p_in_rect } from './src/tile.ts';
    import { select } from 'd3-selection';
  
    //definisco i valori iniziali del grafo
    const prefs = {
      source_url: '/tiles', // the output of the quadfeather tiling engine
      max_points: 1000000000,
      alpha: 100, // Saturation. 0 - transparent, 100 - solid
      zoom_balance: 0.7, // Rate at which points increase size. https://observablehq.com/@bmschmidt/zoom-strategies-for-huge-scatterplots-with-three-js
      point_size: 2,
      background_color: 'black',
      click_function: "window.open(datum.doi, '_blank').focus();",
      //click_function: "console.log(datum);",

      // encoding API based roughly on Vega Lite: https://vega.github.io/vega-lite/docs/encoding.html
      encoding: {
        color: {
          field: 'subject_area',
          domain: ['A+1702', 'A+1800', 'A+1801', 'A+1802', 'A+1803', 'A+1804', 'A+2613'],
          /*range: [
            'limegreen',
            'darkturquoise',
            'royalblue',
            'magenta',
            'gold',
            'red',
            'orangered'
          ],*/
          range: [
            '#2ecc71', //verde chiaro
            '#0074cc', //rosa
            '#FF5733', //arancione
            '#9b59b6', //viola
            '#f39c12', //giallo
            '#3498db', //azzurro
            '#d9534f', //rosso
          ],
          /*range: [
            '#D5EDB9', //verde chiaro
            '#A4E1E9', //azzurro chiaro
            '#789CCE', //blu
            '#C4BDF3', //viola
            '#FBE8A4', //giallo
            '#FAC9DC', //rosso
            '#FFC198', //arancione
          ],*/
          /*range: [
            '#c0e57c', //(Lime Green desaturato)
            '#8ae6e8', //(Dark Turquoise desaturato)
            '#789CCE', //(Royal Blue desaturato)
            '#e586f2', //(Magenta desaturato)
            '#fcd875', //(Gold desaturato)
            '#cc6b6b', //(Rosso desaturato)
            '#f5b4a1', //(Orange Red desaturato)
          ]*/
          /*range: [
            '#1abc9c', //(Turchese)
            '#3498db', //(Blu)
            '#e74c3c', //(Rosso)
            '#2ecc71', //(Verde)
            '#f39c12', //(Giallo)
            '#9b59b6', //(Viola)
            '#FF5733', //(Arancione)
          ]*/
        },
        x: {
          field: 'x',
          transform: 'literal',
        },
        y: {
          field: 'y',
          transform: 'literal',
        },
      },
    };
  
    const scatterplot = new Scatterplot('#deepscatter');
    const plot = scatterplot.plotAPI(prefs);

    select('#search-btn').on("click", (event, data) => search());
    select('#search-reset-btn').on("click", (event, data) => resetSearchFilter());
    select('#rect-search-btn').on("click", (event, data) => rectFilter());
    select('#rect-reset-btn').on("click", () => resetRectFilter());

    select('#swap-palette-btn').on("click", () => swapPalette());
    select('#hide-labels-btn').on("click", () => showHideLabels());

    // Gestione modal
    document.getElementById("info-btn").onclick = function() {
      document.getElementById("info-modal").style.display = "block";
    }
    document.getElementsByClassName("close-modal")[0].onclick = function() {
      document.getElementById("info-modal").style.display = "none";
    }
    window.onclick = function(event) {
      if (event.target == document.getElementById("info-modal")) {
        document.getElementById("info-modal").style.display = "none";
      }
    }
    
    document.getElementById("query-value").addEventListener("keypress", (event) => eventSearch(event) );


    plot.then( () => paint_legend() )
    
    let palette = 0;
    let visible_keywords = true;
    let visible_categories = [1, 1, 1, 1, 1, 1, 1]

    /* Funzione per stampare la legenda filtrabile in alto a destra*/
    function paint_legend() {
      const scale = scatterplot._renderer.aes.store.color.current.scale;

      //creo la legenda per subject_area
      let domain = [
        'Artificial Intelligence', 'General Decision Science','Decision Sciences',
        'Information Systems and Management','Management Science and Operations Research',
        'Statistics, Probability and Uncertainty',
        'Statistics and Probability', 'Reset'
      ]

      select('#color-legend')
        .selectAll('button')
        .data(domain)
        .join('button')
        .attr('class', 'legend-div')
        .attr('id', (d) => d)
        .text((d) => d)
        .on("click", (event, d) => filterSubjectArea(d))
        .style('background-color', (d) => scale(d));
    }

    /* MOSTRO LE KEYWORD SOPRA AI PUNTI */
    plot.then(async (d) => {
      await scatterplot.add_labels_from_url(
        '/tests/keywords.geojson',
        'keywords',
        'name',
        undefined, // size parameter in geojson
        { draggable_labels: true, margin: 7, useColorScale: true }
      );
    });

    /* RENDO LE KEYWORD CLICCABILI */
    scatterplot.label_click = (datum) => { filterByKeyword(datum) };

    /* ESEMPI DI FILTRO:

      RANGE DI VALORI a-b (within)
        encoding: {
          filter: {
            field: 'x',
            op: 'within',
            a: 1,
            b: 10,
          },
        };
      
      MAGGIORE / MINORE / UGUALE rispetto ad a ( gt / st / eq )
        encoding: {
          filter: {
            field: 'x',
            op: 'gt',
            a: 12.3,
          },
        };
      
      FILTERING PER STRINGHE / FUNZIONI (lambda)
        encoding: {
          filter: {
            field: 'x',
            lambda: 'd => d=="Ciao" '
          },
        };

    */

    //CODICE PER TOOLTIP
    scatterplot.tooltip_html = (datum) => {
      
      let subject = 'Artificial Intelligence';
      //console.log(datum.pubdate, typeof(datum.pubdate))

      switch (datum.subject_area){
        case 'A+1702': subject = 'Artificial Intelligence'; break;
        case 'A+1800': subject = 'General Decision Science'; break;
        case 'A+1801': subject = 'Decision Sciences'; break;
        case 'A+1802': subject = 'Information Systems and Management'; break;
        case 'A+1803': subject = 'Management Science and Operations Research'; break;
        case 'A+1804': subject = 'Statistics, Probability and Uncertainty'; break;
        case 'A+2613': subject = 'Statistics and Probability'; break;
        case 'A+1833': subject = 'Data Science'; break;
        default: subject = 'Altro'; break;
      }

      return `<div class="tooltip-data">
                <dl>
                  <dt>id</dt>
                    <dd>${datum.pubid}</dd>
                  <dt>eid</dt>
                    <dd><a href="${datum.doi}">${datum.eid}</a></dd>
                  <dt>publication year</dt>
                    <dd> ${datum.pubdate.getFullYear()} </dd>
                  <dt>authors</dt>
                    <dd> ${datum.authors} </dd>
                  <dt>title</dt>
                    <dd> <b>${datum.title}</b> - ${datum.pubname}</dd>
                  <dt>subject area</dt>
                    <dd>${subject}</dd>
                </dl>
              </div>`;
    };

    

    //FUNZIONE PER FLIPPARE IL GRAFO (inutile)
    /*let cycle = 1
    select('#flip').on('click', () => {
      if ( cycle %2 ) {
        const new_coding = {
          encoding: {
            x: {
              field: 'y',
              transform: 'literal',
            },
            y: {
              field: 'x',
              transform: 'literal',
            },
          },
        };

        cycle++;
        scatterplot.plotAPI(new_coding);
      } else {
        const new_coding = {
          encoding: {
            x: {
              field: 'x',
              transform: 'literal',
            },
            y: {
              field: 'y',
              transform: 'literal',
            },
          },
        };

        cycle++;
        scatterplot.plotAPI(new_coding);
      }
    });*/

    //FILTRO IL GRAFO PER subject_area
    function filterSubjectArea(d) {
      
      switch (d){
        case 'Artificial Intelligence' :  visible_categories[0] = !visible_categories[0]; break;
        case 'General Decision Science' : visible_categories[1] = !visible_categories[1]; break;
        case 'Decision Sciences' : visible_categories[2] = !visible_categories[2]; break;
        case 'Information Systems and Management' : visible_categories[3] = !visible_categories[3]; break;
        case 'Management Science and Operations Research' : visible_categories[4] = !visible_categories[4]; break;
        case 'Statistics, Probability and Uncertainty' : visible_categories[5] = !visible_categories[5]; break;
        case 'Statistics and Probability' : visible_categories[6] = !visible_categories[6]; break;
        default: {
          visible_categories = [1, 1, 1, 1, 1, 1, 1];
          setFilterButtonState();
          const reset = {encoding:{ filter: null}};
          scatterplot.plotAPI(reset);
          return;
        }
      }

      let domain = ['A+1702','A+1800','A+1801','A+1802','A+1803','A+1804','A+2613'];
      let cat = ""
      let tot = 0

      for(let i=0; i<visible_categories.length; i++){
        if(visible_categories[i]){
          cat += "d=='"+domain[i]+"'||";
          tot++;
        }
      }
      cat = cat.slice(0, cat.length-2);
      
      if (tot == 0) {
        visible_categories = [1, 1, 1, 1, 1, 1, 1];
      }

      setFilterButtonState();

      const new_coding = {
        encoding:{
          filter:{
            field:'subject_area',
            lambda: `d => ${cat}`
          }
        }
      };

      console.log("NEW FILTER: ",new_coding);
      scatterplot.plotAPI(new_coding); 
    }

    function setFilterButtonState(){

      const scale = scatterplot._renderer.aes.store.color.current.scale;
      let div = document.getElementById("color-legend").children

      //console.log(scale(i))

      for (let i=0; i<visible_categories.length; i++){
        if(visible_categories[i]){
          div[i].style.backgroundColor = scale(i);
        } else {
          div[i].style.backgroundColor = "grey";
        }
        
      }
    }

    //FILTRO IL GRAFO PER query testuale
    async function search() {
      let query = document.getElementById("query-value").value;
      let field = document.getElementById("query-field").value;
      console.log("Query = ", query, " Field= ", field);

      //rendo case insensitive la ricerca
      query = query.toLowerCase()

      //controllo input
      if (query == ""){
        resetSearchFilter();
        return;
      }

      switch(field){
        case "title": {
          await scatterplot.dataset.register_transformation(`query ${field} : ${query}`, (point) => {
            const term = new RegExp(query);
            // return 1 if it matches, zero if it doesn't
            return point["title"].toLowerCase().match(term) ? 1 : 0;
          });
         }break;
        case "author": {
          await scatterplot.dataset.register_transformation(`query ${field} : ${query}`, (point) => {
            const term = new RegExp(query);
            // return 1 if it matches, zero if it doesn't
            return point["authors"].toLowerCase().match(term) ? 1 : 0;
          });
         }break;
        case "pubdate": {
          await scatterplot.dataset.register_transformation(`query ${field} : ${query}`, (point) => {
            const term = new RegExp(query);
            // return 1 if it matches, zero if it doesn't
            return point["pubdate"].getFullYear().toString().match(term) ? 1 : 0;
          });
         }break;
        default: return;
      }

      //resetto il grafo per evitare bug (filtro non applicati, issue on gitHub)
      //a volte funziona anche senza, va tenuto controllato
      //scatterplot.plotAPI( {encoding: {filter: null}} );

      //fields: title / pubdate / authors
      /*const filter = {
        encoding:{
          filter: {
            field:'subject_area', //field: `${field}`
            lambda: `d => d.search('${q}') >= 0`
          }
        }
      };*/

      const filter = {
        encoding:{
          //point_size: 500, 
          filter2: {
            field: `query ${field} : ${query}`,
            op: "gt",
            a: 0
          }

        }
      };

      console.log("NEW FILTER: ", filter);
      scatterplot.plotAPI(filter);
    }

    function resetSearchFilter(){
      const reset = {encoding:{ filter2: null }};
      //console.log("RESET TEXT FILTER");
      scatterplot.plotAPI(reset);
      return;
    }

    //associato alla searchbar, effettua la ricerca quando viene premuto il tasto Invio
    function eventSearch(event){
        if (event.key == "Enter"){
          search();
        }
        return;
    }

    //Filtro un rettangolo
    async function rectFilter(){
      let x1 = document.getElementById("xmin-value").value;
      let y1 = document.getElementById("ymin-value").value;
      let x2 = document.getElementById("xmax-value").value;
      let y2 = document.getElementById("ymax-value").value;
      console.log("A (", x1,", ",y1, ")  B(", x2,", ",y2, ")");
      let rect = {
        x: [x1, x2],
        y: [y1, y2]
      };

      evaluateRect(rect);
      
      await scatterplot.dataset.register_transformation(`rect : ${x1} ${y1}, ${x2} ${y2}`, (p) => {
        //1 se p si trova nel rettangolo, 0 altrimenti
        return ( p['x'] < rect.x[1] && p['x'] > rect.x[0] && p['y'] < rect.y[1] && p['y'] > rect.y[0]) ? 1 : 0;
      });

      const filter = {
        point_size: 3,
        alpha: 10000,
        encoding:{
          foreground: {
            field: `rect : ${x1} ${y1}, ${x2} ${y2}`,
            op: "gt",
            a: 0
          }
        }
      };   

      console.log("NEW FILTER: ", filter);
      scatterplot._zoom.zoom_to_bbox(rect);
      scatterplot.plotAPI(filter);
      //scatterplot.start_transformations(filter, 110).then( () => scatterplot.plotAPI(filter));
    }

    //Funzione di valutazione dei punti all'interno di una sezione del grafo
    function evaluateRect(rect){
      let tot = 0;
      let totKeywords = 0;
      let keywords = {};
      let avgSubjArea = [0, 0, 0, 0, 0, 0, 0]
      
      //ciclo tra tutti i punti nel rettangolo
      for( const point of scatterplot.dataset.points(rect)){
        tot++;

        //conto le subject area
        switch (point["subject_area"]){
          case "A+1702" : avgSubjArea[0]++; break;
          case "A+1800" : avgSubjArea[1]++; break;
          case "A+1801" : avgSubjArea[2]++; break;
          case "A+1802" : avgSubjArea[3]++; break;
          case "A+1803" : avgSubjArea[4]++; break;
          case "A+1804" : avgSubjArea[5]++; break;
          case "A+2613" : avgSubjArea[6]++; break;
        }

        //estraggo le frequenze delle keyword
        let temp = point["keywords"].split(", ")
        totKeywords += temp.length
        for (const i in temp){
          if (keywords[ temp[i] ]){
            keywords[ temp[i] ] = keywords[ temp[i] ] +1
          } else {
            keywords[ temp[i] ] = 1
          }
        }
      }

      //passo a un array del tipo [['a', 10], ['b', 20], ['c', 30]]
      let sorted = Object.entries(keywords).sort((a, b) => b[1] - a[1]);

      console.log("KEYWORD TOT=", totKeywords);
      for(let i=0; i<10; i++){
        console.log("KEYWORD N",i," =", sorted[i][0], "/", sorted[i][1]);
      }

      console.log("PUNTI TOT=", tot);
      console.log("SUBJECT AREAS: ");
      console.log("A+1702 = ",  avgSubjArea[0]/tot);
      console.log("A+1800 = ",  avgSubjArea[1]/tot);
      console.log("A+1801 = ",  avgSubjArea[2]/tot);
      console.log("A+1802 = ",  avgSubjArea[3]/tot);
      console.log("A+1803 = ",  avgSubjArea[4]/tot);
      console.log("A+1804 = ",  avgSubjArea[5]/tot);
      console.log("A+2613 = ",  avgSubjArea[6]/tot);

      //creo la legenda per subject_area
      let domain = [
        'Artificial Intelligence', 'General Decision Science','Decision Sciences',
        'Information Systems and Management','Management Science and Operations Research',
        'Statistics, Probability and Uncertainty',
        'Statistics and Probability', 'Total Number of Points', 'Total Number of Keywords',
        'Most frequent keywords'
      ]

      for (let i=0; i<7; i++){
        domain[i] = domain[i] + ": " + (avgSubjArea[i]/tot*100).toFixed(2) + '%'
      }
      domain[7] = domain[7] + ": " + tot
      domain[8] = domain[8] + ": " + totKeywords
      domain[9] = domain[9] + ": "

      
      for(let i=0; i<5; i++){
        console.log("KEYWORD N",i," =", sorted[i][0], "/", sorted[i][1]);
        domain[10+i] = sorted[i][0]+": "+sorted[i][1]+" occurrencies"
      }

      select('#selected-rect-legend')
        .selectAll('div')
        .data(domain)
        .join('div')
        .attr('class', 'result-div')
        .attr('id', (d) => d)
        .text((d) => d)
    }

    function resetRectFilter(){
      let rect = {
        x: [-150, 150],
        y: [150, -150]
      };

      const filter = { point_size: 2, alpha: 100, encoding: { foreground: null } };   

      scatterplot._zoom.zoom_to_bbox(rect);
      scatterplot.plotAPI(filter);
    }

    function swapPalette(){

      let theme;

      switch (palette) {

        //Palette 1: ['#1abc9c', //(Turchese),'#3498db', //(Blu),'#e74c3c', //(Rosso),'#2ecc71', //(Verde),'#f39c12', //(Giallo),'#9b59b6', //(Viola),'#FF5733', //(Arancione)   ]
        case 0 : {
          palette = 1;
          const theme = {
            encoding: {
              color: {
                field: 'subject_area',
                domain: ['A+1702', 'A+1800', 'A+1801', 'A+1802', 'A+1803', 'A+1804', 'A+2613'],
                range: [
                  '#1abc9c', //(Turchese)
                  '#3498db', //(Blu)
                  '#e74c3c', //(Rosso)
                  '#2ecc71', //(Verde)
                  '#f39c12', //(Giallo)
                  '#9b59b6', //(Viola)
                  '#FF5733', //(Arancione)  
                ],
              }
            }
          };
          console.log("NEW THEME: ", theme);
          scatterplot.plotAPI(theme).then( () => paint_legend() );
        }break;

        //Palette 3: [ '#2ecc71', //verde chiaro, '#0074cc', //rosa, '#FF5733', //arancione, '#9b59b6', //viola, '#f39c12', //giallo, '#3498db', //azzurro, '#d9534f', //rosso]
        case 1 : {
          palette = 0;
          const theme = {
            encoding: {
              color: {
                field: 'subject_area',
                domain: ['A+1702', 'A+1800', 'A+1801', 'A+1802', 'A+1803', 'A+1804', 'A+2613'],
                range: [
                  '#2ecc71', //verde chiaro
                  '#0074cc', //rosa
                  '#FF5733', //arancione
                  '#9b59b6', //viola
                  '#f39c12', //giallo
                  '#3498db', //azzurro
                  '#d9534f', //rosso
                ]
              }
            }
          };
          console.log("NEW THEME: ", theme);
          scatterplot.plotAPI(theme).then( () => paint_legend() );
        }break;
      }

    }

    async function showHideLabels(){

      if(visible_keywords){

        visible_keywords = false;
        document.getElementById("hide-labels-btn").innerHTML="Show Keyword";

        await scatterplot.add_labels_from_url(
          '/tests/no-keywords.geojson',
          'categories',
          'name',
          undefined, // size parameter in geojson
          { draggable_labels: true, margin: 7, useColorScale: true }
        );

      } else {

        visible_keywords = true;
        document.getElementById("hide-labels-btn").innerHTML="Hide Keyword";

        await scatterplot.add_labels_from_url(
          '/tests/keywords.geojson',
          'categories',
          'name',
          undefined, // size parameter in geojson
          { draggable_labels: true, margin: 7, useColorScale: true }
        );
      }
    }

    async function filterByKeyword(datum){
      console.log(datum.text);

      await scatterplot.dataset.register_transformation(`keyword : ${datum.text}`, (p) => {
        //1 se il punto contiene la keyword, 0 altrimenti
        let split = p['keywords'].split(", ")
        for(let i=0; i<split.length; i++){
          if(split[i] === datum.text){
            return 1;
          }
        }
        return 0;
      });

      const filter = {
        encoding:{
          filter2: {
            field: `keyword : ${datum.text}`,
            op: "gt",
            a: 0
          }
        }
      };   

      console.log("NEW FILTER BY KEYWORD (FILTER 2) : ", filter);
      scatterplot.plotAPI(filter);
    }

  </script>
  

  <style>

    #deepscatter {
      position: absolute;
      top: 0px;
      left: 0px;
      z-index: 0;
    }
  
    /* Styling legend content */
      .overlay {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 99;
      }
    
      #color-legend {
        display: flex;
        flex-direction: column;
        align-items: right;
        justify-content: right;
      }
    
      .legend-div {
        margin: 5px;
        padding: 5px 15px;
        border-radius: 15px;
        border-style: solid;
        border-color: ivory;
        border-width: 1px;
        font-size: 16px;
        font-family:'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        cursor: pointer;
      }

      .legend-div:hover {
        opacity: 75%;
      }

      #reset{
        background: ivory !important;
      }
    /* fine styling legend*/

    /* Styling tooltip content */
      .tooltip {
        z-index: 99;
        opacity: 1 !important;
        min-width: 300px !important;
        border-radius: 8px;
        background: ivory;
      }

      dl {
        display: flex;
        flex-direction: column;
        flex-wrap: wrap;
      }

      dt {
        font-weight: bold;
        font-variant: small-caps;
        color: rgb(128, 19, 0);
      }

      dt::after {
        content: ':';
      }

      dd {
        margin: 0 0 0 10px;
        padding: 0 0 0.5em 0;
      }
    /* fine styling tooltip*/

    /* styling searchbar */
      .searchbar {
        position: fixed;
        background-color: ivory;
        border-radius: 10px;
        margin: 10px 0 0 10px;
        padding: 10px 20px 20px 20px;
      }

      .query-input {
        font-family:'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        min-height: 40px;
        margin-right: 3px;
        padding: 0.5em;
        border-style: solid;
        border-radius: 10px;
        border-color: antiquewhite;
      }

      .query-input:hover, .query-input:focus {
        background-color: antiquewhite !important;
      }

      .search-btn {
        padding-left: 15px;
        padding-right: 15px;
        background-color:white;
        cursor: pointer;
      }

      #query-value {
        min-width: 200px;
        background-image: url('searchicon.png');
        background-position: 10px 7px;
        background-repeat: no-repeat;
        padding-left: 40px;
      }
      
      .search-title {
        font-family:'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        text-align: center;
        font-size: 25px;
        color: darksalmon;
        margin-top: 0px;
        padding-top: 5px;
      }

    /* fine styling searchbar */

    /* scrollbar style */
    
      /*
      ::-webkit-scrollbar-track
      {
        -webkit-box-shadow: inset 0 0 3px rgba(0,0,0,0.3);
        background-color: #F5F5F5;
      }

      ::-webkit-scrollbar
      {
        width: 7px;
        height: 7px; 
        background-color: #F5F5F5;
      }

      ::-webkit-scrollbar-thumb
      {
        background-color: #000000;
        border: 1px solid #555555;
      }*/
      
      
      ::-webkit-scrollbar
      {
        width: 0px; 
        height: 0px;
      }
      
    /* fine scrollbar style */
    
    /* styling casella ricerca area */
      .rect-search {
        position: fixed;
        background-color: ivory;
        border-radius: 10px;
        margin: 150px 0 0 10px;
        padding: 10px 20px 20px 20px;
      }

      .rect-search-input {
        max-width: 80px;
        margin-bottom: 3px;
        text-align: center;
      }

      #rect-search-btn {
        margin-left: 50px;
        min-width: 100px;
      }

      .result-div {
        padding-top: 8px;
        padding-left: 5px;
        font-size: 16px;
        font-family:'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
      }

      .result-div:hover {
        font-size: 18px;
        /*background-color:rgba(233, 221, 167, 0.733);*/
      }

      .box {
        float: left;
        height: 20px;
        width: 20px;
        margin-bottom: 15px;
        border: 1px solid grey;
        clear: both;
      }

      .red {
        background-color: red;
      }

      .green {
        background-color: green;
      }

      .blue {
        background-color: blue;
      }
    /* fine styling casella ricerca area */

    /* styling barra extra */
      .extra-options {
        position: fixed;
        bottom: 20px;
        right: 20px;
        /*background-color: #555;*/
      }

      .extra-btn {
        border-radius: 15px;
        border-style: solid;
        border-color: ivory;
        border-width: 1px;
        font-family:'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        font-size: 16px;
        color: #ffffff;
        background-color: #000000;
        padding: 5px 15px;
        cursor: pointer;
      }

      .extra-btn:hover {
        background-color: #292929;
      }
      
      /* styling modal */
        .modal {
          display: none;
          position: fixed;
          z-index: 1; /* Overlay */
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          overflow: auto; /* Enable scroll if needed */
          background-color: rgba(0,0,0,0.4); /* colore overlay */
          -webkit-animation-name: fadeIn;
          -webkit-animation-duration: 0.4s;
          animation-name: fadeIn;
          animation-duration: 0.4s
        }

        /* Modal Content */
        .modal-content {
          position: fixed;
          bottom: 0;
          background-color: #4e4e4e;
          width: 100%;
          -webkit-animation-name: slideIn;
          -webkit-animation-duration: 0.4s;
          animation-name: slideIn;
          animation-duration: 0.4s;
        }

        .modal-header {
          padding: 2px 16px;
        }

        .modal-body {
          padding: 2px 16px;
          text-align: center;
          color: white;
        }

        .modal-footer {
          padding: 2px 16px;
          text-align: center;
          background-color: #4e4e4e;
          color: white;
        }

        /* The Close Button */
          .close-modal {
            color: #ffffff;
            float: right;
            margin-right: 10px;
            font-size: 40px;
            font-weight: bold;
          }

          .close-modal:hover,
          .close-modal:focus {
            color: #ffffff;
            text-decoration: none;
            cursor: pointer;
          }

        /* Add Animation */
        @-webkit-keyframes slideIn {
          from {bottom: -300px; opacity: 0} 
          to {bottom: 0; opacity: 1}
        }

        @keyframes slideIn {
          from {bottom: -300px; opacity: 0}
          to {bottom: 0; opacity: 1}
        }

        @-webkit-keyframes fadeIn {
          from {opacity: 0} 
          to {opacity: 1}
        }

        @keyframes fadeIn {
          from {opacity: 0} 
          to {opacity: 1}
        }
      /*fine styling modal*/
    
    /* fine styling barra extra */

  </style>


  <script>
    /*
    import init, { count_regex_matches } from '$lib/wasm_regex/wasm_regex';


    export default async function apply_search(query, field, duration = 500, plot, on_find = (d: FindResults) => undefined) {
      await run_search(query, plot, field, on_find);
      if (query === '') {
        return plot.plotAPI({
          duration,
          encoding: {
            filter: null,
            color: {
              constant: 'orange'
            },
            size: {
              constant: 1
            },
            foreground: null
          }
        });
      } 
      return plot.plotAPI({
        duration,
        alpha: 50,
        encoding: {
          filter: null,
          color: {
            field: `search: (${field}) ${query}`,
            domain: [0, 1],
            range: ['gray', 'orange']
          },
          size: {
            field: `search: (${field}) ${query}`,
            domain: [0, 1],
            range: [1, 2]
          },
          foreground: {
            field: `search: (${field}) ${query}`,
            op: 'eq',
            a: 1
          }
        }
      });

    }

    export type FindResults = {
      matches: any[],
      tile: any,
      hits: number
    }

    async function run_search(query, plot, field, on_find = (d : FindResults) => undefined) {
      if (query === '') {
        return;
      }
      await init();
      plot._root.transformations[`search: (${field}) ${query}`] = async function (tile) {
        const data = tile.record_batch.getChild(field).data[0];
        const values = data.values;
        const offsets = data.valueOffsets;
        const matches_in_batches = count_regex_matches(values, offsets, query, true);
        const matches = [];
        let hits = 0;
        for (let i = 0; i < matches_in_batches.length; i++) {
          if (matches_in_batches[i] > 0) {
            matches.push(tile.record_batch.get(i))
            hits += 1
          }
        }
        on_find({matches, tile, hits});
        return matches_in_batches
      };
    }
    */
  </script>